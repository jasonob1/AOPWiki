library(igraph)
par(bg="black")
workingDir <-"C://Users/NPollesc/Desktop/GitHub/AOPwiki/" #EPA Dir
# workingDir<- "C://Users/Nathan Pollesch/Documents/GitHub/AOPWiki/" #Personal Dir
setwd(workingDir)
KERimport <- "data/all-KERs.txt"
KEimport <- "data/all-KEs.txt"
KEplus <- "data/all_KEs_plus.txt"
source(paste(workingDir,"R_files/AOP_net_functions.R",sep="")) #imports custom functions
KERdata<-read.table(paste(workingDir, KERimport, sep=""), sep="\t", stringsAsFactors=FALSE, header=TRUE)
KEdata<-read.table(paste(workingDir, KEimport, sep=""), sep="\t", stringsAsFactors=FALSE, header=TRUE)
KEPdata<-read.table(paste(workingDir, KEplus, sep=""), sep="\t", stringsAsFactors=FALSE, header=TRUE)
#Format KEPdata for easier handling later
KEPdata[,1]<-as.numeric(substring(KEPdata[,1],5)) #strips the characters Aop: from AOPID column and turns the result numeric
KEPdata[,3]<-as.numeric(substring(KEPdata[,3],7)) #strips the characters Event: from the Event ID column and turns the result numeric
##  Identify all unique KEs
allKEs<-c(KERdata[,2],KERdata[,4])
uniqueKEs<-unique(allKEs)
keID<-data.frame(ID=1:length(uniqueKEs),KE=uniqueKEs)
KERs<-cbind(match(KERdata[,2], keID[,2]),match(KERdata[,4], keID[,2]))
AOPg<-graph_from_edgelist(KERs, directed=T)
## Add names for key event nodes
V(AOPg)$KE_name<-as.character(keID$KE)
V(AOPg)$name<-keID$KE
V(AOPg)$KE_EID<-KEdata[match(V(AOPg)$KE_name,KEdata[,2]),1] # adds event ID number
V(AOPg)$AOP_ID<-KEPdata[match(V(AOPg)$KE_EID,KEPdata[,3]),1] # finds AOPID to add to V(AOPg) data
# This identifies which KEs are included in KERs, but are not themselves included in the KE event listings.
# V(AOPg)$KE_name[which(is.na(V(AOPg)$KE_EID))]
# Plot the AOP wiki, colored by AOP
acols=topo.colors(length(unique(V(AOPg)$AOP_ID)))
for(i in 1:length(unique(V(AOPg)$AOP_ID))){
V(AOPg)[which(V(AOPg)$AOP_ID==unique(V(AOPg)$AOP_ID)[i])]$acol<-acols[i]
}
par(bg="black",xpd=FALSE)
set.seed(1)
plot(AOPg,vertex.color=V(AOPg)$acol,vertex.label=NA, vertex.size=2, edge.arrow.size=.1)
AOP_freqs<-table(V(AOPg)$AOP_ID)
bp_wcc<-barplot(table(V(AOPg)$AOP_ID),col.axis="white", xlab="AOP ID",ylab="# Key Events",col.lab="white")
abline(h=mean(AOP_freqs),col="red")
#  TASK: WORK ON EDGE COLORING FOR AOP ID
#  edgecombcc<-expand.grid(V(gr)[which(comps$membership==ntcomps[i])],V(gr)[which(comps$membership==ntcomps[i])]) #creates a pairwise list of all nodes in the cc
#  edgecombflat<-as.vector(rbind(edgecombcc[[1]],edgecombcc[[2]])) #flattens the pairwise list to a vector where entries are read pairwise
#  edges.in.cc<-get.edge.ids(gr,edgecombflat,directed=TRUE)
#  E(gr)$color[edges.in.cc]<-cols[[i]]
#### CONNECTED COMPONENTS ANALYSIS ####
## Color vertices and edges by their weakly or strongly connected components.
V(AOPg)$cc_color<-unlist(color.comps(AOPg,"strong")$vcol)  #color.comps is a custom function stored in the AOP_net_functions.R file
E(AOPg)$cc_color<-unlist(color.comps(AOPg,"strong")$ecol)  #color.comps is a custom function stored in the AOP_net_functions.R file
# When the "strong" option is passed to color.comps, vsize and ewidth are calculated and can be used within plot
V(AOPg)$cc_size<-unlist(color.comps(AOPg,"strong")$vsize)
E(AOPg)$cc_width<-unlist(color.comps(AOPg,"strong")$ewidth)
# plot of connected components
par(bg="black")
set.seed(1)
plot(AOPg, vertex.size=V(AOPg)$cc_size, edge.width=E(AOPg)$cc_width, vertex.color=V(AOPg)$cc_color, edge.color=E(AOPg)$cc_color, edge.arrow.size=.1, vertex.label=NA)
## barplot for size of weakly connected components
wcomps<-components(AOPg,mode="weak")
wcc_freqs<-table(wcomps$csize)
bp_wcc<-barplot(table(wcomps$csize),col.axis="white", xlab="Component size",ylab="Frequency",col.lab="white")
# This points out how many of the feedback loops/cycles are contained within the same AOP and how many are a result of the network
scomps<-components(AOPg,mode="strong")
ntcomps<-which(scomps$csize>1) # non-trivial ccs (i.e. with more than 1 node)
V(AOPg)$scc<-scomps$membership # assign the attribute scc to nodes based on their membership
for(i in 1:length(ntcomps)){
print(V(AOPg)[which(V(AOPg)$scc==ntcomps[i])]$AOP_ID)
}
#### Level of biological organization plot ####
## Add level of biological organization for key event nodes
V(AOPg)$lobo<-KEdata[[4]][match(V(AOPg)$KE_name,KEdata[[2]])]
V(AOPg)$lobo[which(is.na(V(AOPg)$lobo))]<-"" #assigns blank to NA data
tcols=rainbow(length(unique(V(AOPg)$lobo))) #creates a color scheme for visualization
lobo_order=c("Molecular","Cellular","Tissue","Organ","Individual","Population","") #creates an ordering of biological organization
V(AOPg)$lobo_o<-match(V(AOPg)$lobo,lobo_order) #assigns a value of biological organization instead of string.  1=molecular, 2=cellular, ...
lobo_freqs<-table(V(AOPg)$lobo_o)
## Barplot of lobo frequency
par(bg="black")
xx<- barplot(table(V(AOPg)$lobo_o), col=tcols, axes=F,names.arg=NA)
text(x=xx, y=10, label=lobo_freqs, cex=.75)
legend('topright',c("Molecular","Cellular","Tissue","Organ","Individual","Population","Not Specified"), pch=22,
col="#777777", xjust=1,yjust=1, pt.bg=tcols, pt.cex=2, cex=.8, bty="n", ncol=1, y.intersp=.5, box.col="black", text.col="white")
#plot the AOP wiki by lobo info
V(AOPg)$lobo_col<-tcols[V(AOPg)$lobo_o]
set.seed(1)
plot(AOPg, vertex.size=2, edge.color="gray", edge.arrow.size=.1, vertex.label=NA, vertex.color=V(AOPg)$lobo_col)
eccentricity(AOPg,mode ="all")
sort(eccentricity(AOPg,mode ="all"))
View(deg.col)
V(AOPg)$deg_col<-deg.col(AOPg,dmode="all")
plot(AOPg, vertex.size=2, vertex.color=V(AOPg)$deg_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
plot(AOPg, vertex.size=500*degree(AOPg,mode="all",normalized=TRUE), vertex.color=V(AOPg)$deg_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
barplot(table(degree(AOPg,mode="all")),col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="all")))))
barplot(table(degree(AOPg,mode="all")), xlab="Degree (all)", ylab="# of KEs with Degree",col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="all")))))
barplot(table(degree(AOPg,mode="all")), xlab="Degree (all)", ylab="# of KEs with Degree (all)",col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="all")))))
barplot(table(degree(AOPg,mode="all")), xlab=paste("Degree (all)",expression(D_(all)),sep="") ylab="# of KEs with Degree (all)",col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="all")))))
barplot(table(degree(AOPg,mode="all")), xlab=paste("Degree (all)",expression(D_(all)),sep=""), ylab="# of KEs with Degree (all)",col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="all")))))
barplot(table(degree(AOPg,mode="all")), xlab=paste("Degree (all)",expression(D[all]),sep=""), ylab="# of KEs with Degree (all)",col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="all")))))
barplot(table(degree(AOPg,mode="all")), xlab="Degree (all)", ylab="# of KEs with Degree (all)",col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="all")))))
V(AOPg)$deg_col<-deg.col(AOPg,dmode="in")
degree(AOPg,mode="in")
sort(degree(AOPg,mode="in"))
View(deg.col)
deg.col<-function(gr,dmode="all"){
gd<-degree(gr,mode=dmode)
heatcol=rev(heat.colors(max(gd+1)))
gdcols<-heatcol[gd+1]
return(gdcols)
}
V(AOPg)$deg_col<-deg.col(AOPg,dmode="in")
barplot(table(degree(AOPg,mode="in")), xlab="Degree (in)", ylab="# of KEs with Degree (in)",col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="in")))))
deg.col<-function(gr,dmode="all"){
gd<-degree(gr,mode=dmode)
heatcol=rev(heat.colors(max(gd)+1))
gdcols<-heatcol[gd+1]
return(gdcols)
}
barplot(table(degree(AOPg,mode="in")), xlab="Degree (in)", ylab="# of KEs with Degree (in)",col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="in"))+1)))
plot(AOPg, vertex.size=500*degree(AOPg,mode="in",normalized=TRUE), vertex.color=V(AOPg)$deg_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
set.seed(1)
plot(AOPg, vertex.size=500*degree(AOPg,mode="in",normalized=TRUE), vertex.color=V(AOPg)$deg_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
V(AOPg)$deg_col<-deg.col(AOPg,dmode="all")
plot(AOPg, vertex.size=2, vertex.color=V(AOPg)$deg_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
plot(AOPg, vertex.size=500*degree(AOPg,mode="all",normalized=TRUE), vertex.color=V(AOPg)$deg_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
set.seed(1)
plot(AOPg, vertex.size=500*degree(AOPg,mode="all",normalized=TRUE), vertex.color=V(AOPg)$deg_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
barplot(table(degree(AOPg,mode="all")), xlab="Degree (all)", ylab="# of KEs with Degree (all)",col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="all"))+1)))
V(AOPg)$deg_col<-deg.col(AOPg,dmode="in")
#colored by degree
plot(AOPg, vertex.size=2, vertex.color=V(AOPg)$deg_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
#colored by degree and sized by degree
set.seed(1)
plot(AOPg, vertex.size=500*degree(AOPg,mode="in",normalized=TRUE), vertex.color=V(AOPg)$deg_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
#barplot to show degree histogram
barplot(table(degree(AOPg,mode="in")), xlab="Degree (in)", ylab="# of KEs with Degree (in)",col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="in"))+1)))
sort(degree(AOPg,mode="in"))
V(AOPg)$KE_name[which(V(AOPg)$name==449)]
sort(degree(AOPg, mode="all"))
V(AOPg)$KE_name[which(V(AOPg)$name==449)]
set.seed(1)
plot(AOPg, vertex.size=500*degree(AOPg,mode="in",normalized=TRUE), vertex.color=V(AOPg)$deg_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
sort(degree(AOPg,mode="out"))
V(AOPg)$KE_name[which(V(AOPg)$name==345)]
V(AOPg)$deg_col<-deg.col(AOPg,dmode="out")
set.seed(1)
plot(AOPg, vertex.size=500*degree(AOPg,mode="out",normalized=TRUE), vertex.color=V(AOPg)$deg_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
barplot(table(degree(AOPg,mode="in")), xlab="Degree (out)", ylab="# of KEs with Degree (out)",col.axis="white", col.lab="white",col=rev(heat.colors(max(degree(AOPg,mode="out"))+1)))
wbpal=colorRampPalette(c("white","blue"))
wbpal(15)
sort(betweenness(AOPg))
which(V(AOPg)$name==345)
V(AOPg)$cent_size[which(V(AOPg)$name==345)]<-3
which(V(AOPg)$name==345)
V(AOPg)$KE_name[which(V(AOPg)$name==345)]
V(AOPg)$bet_col<-wbpal(10)[as.numeric(cut(betweenness(AOPg),breaks = 10))]
plot(AOPg, vertex.size=2, vertex.color=V(AOPg)$bet_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
#colored by degree and sized by degree
plot(AOPg, vertex.size=1000*betweenness(AOPg,normalized=TRUE), vertex.color=V(AOPg)$bet_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
set.seed(1)
plot(AOPg, vertex.size=2000*betweenness(AOPg,normalized=TRUE), vertex.color=V(AOPg)$bet_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
wbpal=colorRampPalette(c("yellow","blue"))
V(AOPg)$bet_col<-wbpal(10)[as.numeric(cut(betweenness(AOPg),breaks = 10))]
set.seed(1)
plot(AOPg, vertex.size=2000*betweenness(AOPg,normalized=TRUE), vertex.color=V(AOPg)$bet_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
wbpal=colorRampPalette(c("yellow","blue"))
V(AOPg)$bet_col<-wbpal(20)[as.numeric(cut(betweenness(AOPg),breaks = 20))]
set.seed(1)
plot(AOPg, vertex.size=2000*betweenness(AOPg,normalized=TRUE), vertex.color=V(AOPg)$bet_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
wbpal=colorRampPalette(c("white","blue"))
V(AOPg)$bet_col<-wbpal(20)[as.numeric(cut(betweenness(AOPg),breaks = 20))]
set.seed(1)
plot(AOPg, vertex.size=2000*betweenness(AOPg,normalized=TRUE), vertex.color=V(AOPg)$bet_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
set.seed(1)
plot(AOPg, vertex.size=3000*betweenness(AOPg,normalized=TRUE), vertex.color=V(AOPg)$bet_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
barplot(table(as.numeric(cut(betweenness(AOPg),breaks = 20))),col=wbpal(20))
sort(betweenness(AOPg))
hist(betweenness(AOPg))
hist(betweenness(AOPg),col=wbpal(20))
hist(betweenness(AOPg),col=wbpal(10))
hist(betweenness(AOPg),col=blue)
hist(betweenness(AOPg),col="blue")
hist(betweenness(AOPg),breaks=20,col="blue")
hist(betweenness(AOPg),breaks=10,col="blue")
hist(betweenness(AOPg, normalized=TRUE),breaks=10,col="blue")
hist(3000*betweenness(AOPg, normalized=TRUE),breaks=10,col="blue")
hist(betweenness(AOPg, normalized=TRUE),breaks=10,col="blue")
plot(betweenness(AOPg))
plot(betweenness(AOPg),col="blue")
plot(sort(betweenness(AOPg),col="blue"))
plot(sort(betweenness(AOPg)),col="blue")
source('C:/Users/NPollesc/Desktop/GitHub/AOPWiki/R_files/AOP_wiki_analysis.R', echo=TRUE)
barplot(sort(betweenness(AOPg)),col="blue")
plot(sort(betweenness(AOPg)),col="blue")
plot(sort(as.numeric(cut(betweenness(AOPg),breaks=20))),col=wbpal(20), col.axes="white",col.label="white")
plot(sort(as.numeric(cut(betweenness(AOPg),breaks=20))),col="blue", col.axes="white",col.label="white")
plot(sort(as.numeric(cut(betweenness(AOPg),breaks=20))),col="blue", col.axes="white",col.lab="white")
warnings()
plot(sort(as.numeric(cut(betweenness(AOPg),breaks=20))),col="blue", col.axis="white",col.lab="white")
plot(sort(betweenness(AOPg)),col="blue", col.axis="white",col.lab="white")
plot(sort(betweenness(AOPg,normalized=T)),col="blue", col.axis="white",col.lab="white")
plot(sort(betweenness(AOPg)),col="blue", col.axis="white",col.lab="white")
sort(betweenness(AOPg))
V(AOPg)$KE_name[which(V(AOPg)$name==345)]
table(betweeness(AOPg))
table(betweenness(AOPg))
sort(betweenness(AOPg,directed=TRUE))
set.seed(1)
plot(AOPg, vertex.size=3000*betweenness(AOPg,normalized=TRUE,directed=T), vertex.color=V(AOPg)$bet_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
V(AOPg)$bet_col<-wbpal(20)[as.numeric(cut(betweenness(AOPg,directed=TRUE),breaks = 20))]
set.seed(1)
plot(AOPg, vertex.size=3000*betweenness(AOPg,normalized=TRUE,directed=T), vertex.color=V(AOPg)$bet_col, edge.arrow.size=.1, vertex.label=NA, edge.color="gray",edge.width=1)
table(betweenness(AOPg,directed=TRUE))
plot(sort(betweenness(AOPg)),col="blue", col.axis="white",col.lab="white")
plot(sort(betweenness(AOPg)),col="blue", col.axis="white",col.lab="white", pch=10)
#Script by A. Roberts, 2013.
#To run the script, copy and paste it onto the R command line, and press ,<enter>.
KochSnowflakeExample <- function(){
iterate <- function(T,i){
A = T[ ,1]; B=T[ ,2]; C = T[,3];
if (i == 1){
d = (A + B)/2; h = (C-d); d = d-(1/3)*h;
e = (2/3)*B + (1/3)*A; f = (1/3)*B + (2/3)*A;
}
if (i == 2){
d = B; e = (2/3)*B + (1/3)*C; f = (2/3)*B + (1/3)*A;
}
if (i == 3){
d = (B + C)/2; h = (A-d); d = d-(1/3)*h;
e = (2/3)*C + (1/3)*B; f = (1/3)*C + (2/3)*B;
}
if (i == 4){
d = C; e = (2/3)*C + (1/3)*A; f = (2/3)*C + (1/3)*B;
}
if (i == 5){
d = (A + C)/2; h = (B-d); d = d-(1/3)*h;
e = (2/3)*A + (1/3)*C; f = (1/3)*A + (2/3)*C;
}
if (i == 6){
d = A; e = (2/3)*A + (1/3)*C; f = (2/3)*A + (1/3)*B;
}
if (i == 0){
d = A; e = B; f = C;
}
Tnew = cbind(d,e,f)
return(Tnew); #Return a smaller triangle.
}
draw <- function(T, col=rgb(0,0,0),border=rgb(0,0,0)){
polygon(T[1,],T[2,],col=col,border=border)
}
Iterate = function(T,v,col=rgb(0,0,0),border=rgb(0,0,0)){
for (i in v) T = iterate(T,i);
draw(T,col=col,border=border);
}
#The vertices of the initial triangle:
A = matrix(c(1,0),2,1);
B = matrix(c(cos(2*pi/3), sin(2*pi/3)),2,1);
C = matrix(c(cos(2*pi/3),-sin(2*pi/3)),2,1);
T0 = cbind(A,B,C);
plot(numeric(0),xlim=c(-1.1,1.1),ylim=c(-1.1,1.1),axes=FALSE,frame=FALSE,ann=FALSE);
par(mar=c(0,0,0,0),bg=rgb(1,1,1));
par(usr=c(-1.1,1.1,-1.1,1.1));
#Draw snowflake:
for (i in 0:6) for (j in 0:6) for (k in 0:6) for (l in 0:6) Iterate(T0,c(i,j,k,l));
}
KochSnowflakeExample(); #Run the example.
#Script by A. Roberts, 2013.
#To run the script, copy and paste it onto the R command line, and press ,<enter>.
KochSnowflakeExample <- function(){
iterate <- function(T,i){
A = T[ ,1]; B=T[ ,2]; C = T[,3];
if (i == 1){
d = (A + B)/2; h = (C-d); d = d-(1/3)*h;
e = (2/3)*B + (1/3)*A; f = (1/3)*B + (2/3)*A;
}
if (i == 2){
d = B; e = (2/3)*B + (1/3)*C; f = (2/3)*B + (1/3)*A;
}
if (i == 3){
d = (B + C)/2; h = (A-d); d = d-(1/3)*h;
e = (2/3)*C + (1/3)*B; f = (1/3)*C + (2/3)*B;
}
if (i == 4){
d = C; e = (2/3)*C + (1/3)*A; f = (2/3)*C + (1/3)*B;
}
if (i == 5){
d = (A + C)/2; h = (B-d); d = d-(1/3)*h;
e = (2/3)*A + (1/3)*C; f = (1/3)*A + (2/3)*C;
}
if (i == 6){
d = A; e = (2/3)*A + (1/3)*C; f = (2/3)*A + (1/3)*B;
}
if (i == 0){
d = A; e = B; f = C;
}
Tnew = cbind(d,e,f)
return(Tnew); #Return a smaller triangle.
}
draw <- function(T, col=rgb(0,0,0),border=rgb(0,0,0)){
polygon(T[1,],T[2,],col=col,border=border)
}
Iterate = function(T,v,col=rgb(0,0,0),border=rgb(0,0,0)){
for (i in v) T = iterate(T,i);
draw(T,col=col,border=border);
}
#The vertices of the initial triangle:
A = matrix(c(1,0),2,1);
B = matrix(c(cos(2*pi/3), sin(2*pi/3)),2,1);
C = matrix(c(cos(2*pi/3),-sin(2*pi/3)),2,1);
T0 = cbind(A,B,C);
plot(numeric(0),xlim=c(-1.1,1.1),ylim=c(-1.1,1.1),axes=FALSE,frame=FALSE,ann=FALSE,col="white");
par(mar=c(0,0,0,0),bg=rgb(1,1,1));
par(usr=c(-1.1,1.1,-1.1,1.1));
#Draw snowflake:
for (i in 0:6) for (j in 0:6) for (k in 0:6) for (l in 0:6) Iterate(T0,c(i,j,k,l));
}
KochSnowflakeExample(); #Run the example.
